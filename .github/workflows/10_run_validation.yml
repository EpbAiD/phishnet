name: 10-Run Validation (Progressive Learning)

# Run 10 iterations of the E2E pipeline:
# Each run collects 100 NEW unique URLs (checking against master dataset)
# Features are extracted and appended to master
# 45 models are trained on the growing dataset
# Best ensemble is evaluated
# Final test shows progressive improvement

on:
  workflow_dispatch:
    inputs:
      run_count:
        description: 'Number of validation runs (1-10)'
        required: false
        default: '10'
      urls_per_run:
        description: 'New URLs to collect per run'
        required: false
        default: '100'

env:
  AWS_REGION: us-east-1
  S3_BUCKET: phishnet-data
  EC2_INSTANCE_ID: i-0c8ab11c281702a22

jobs:
  # ========================================================================
  # Single job that runs all 10 iterations sequentially
  # ========================================================================
  validation:
    name: "Run 10 Validation Iterations"
    runs-on: ubuntu-latest
    timeout-minutes: 600  # 10 hours max

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: pip install -r requirements.txt boto3 pyarrow

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup SSH key for EC2
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/ec2_key
          chmod 600 ~/.ssh/ec2_key
          # Verify key was written
          echo "SSH key file size: $(wc -c < ~/.ssh/ec2_key) bytes"
          head -1 ~/.ssh/ec2_key

      - name: Run validation loop
        run: |
          TOTAL_RUNS="${{ github.event.inputs.run_count || '10' }}"
          URLS_PER_RUN="${{ github.event.inputs.urls_per_run || '100' }}"

          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘         10-RUN PROGRESSIVE LEARNING VALIDATION               â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  Runs: $TOTAL_RUNS | URLs per run: $URLS_PER_RUN                          â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""

          # Create results tracking file
          mkdir -p analysis/validation_runs
          RESULTS_FILE="analysis/validation_runs/results_$(date +%Y%m%d_%H%M%S).csv"
          echo "run,total_urls,new_urls_added,phishing,legitimate,best_accuracy,best_f1,best_ensemble" > $RESULTS_FILE

          for RUN_NUM in $(seq 1 $TOTAL_RUNS); do
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "                    RUN $RUN_NUM of $TOTAL_RUNS"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""

            BATCH_DATE=$(date +%Y%m%d_%H%M%S)
            BATCH_FILE="data/url_queue/batch_${BATCH_DATE}.csv"
            mkdir -p data/url_queue data/processed

            # ------------------------------------------------------------
            # STEP 1: Download master for duplicate checking
            # ------------------------------------------------------------
            echo "ğŸ“¥ Step 1: Downloading master dataset..."
            aws s3 cp s3://${{ env.S3_BUCKET }}/master/phishing_features_master.csv data/processed/phishing_features_complete.csv 2>/dev/null || {
              echo "   Creating new master dataset"
              echo "url,label" > data/processed/phishing_features_complete.csv
            }

            BEFORE_COUNT=$(tail -n +2 data/processed/phishing_features_complete.csv 2>/dev/null | wc -l | tr -d ' ' || echo "0")
            echo "   Master contains $BEFORE_COUNT existing URLs"

            # ------------------------------------------------------------
            # STEP 2: Collect NEW unique URLs
            # ------------------------------------------------------------
            echo ""
            echo "ğŸ”— Step 2: Collecting $URLS_PER_RUN NEW unique URLs..."
            python3 scripts/fetch_urls.py $BATCH_FILE $URLS_PER_RUN || {
              echo "âš ï¸ URL collection failed, trying with smaller batch"
              python3 scripts/fetch_urls.py $BATCH_FILE 50 || true
            }

            if [ ! -f "$BATCH_FILE" ]; then
              echo "âŒ Failed to collect URLs, skipping this run"
              continue
            fi

            # Count results
            TOTAL=$(tail -n +2 $BATCH_FILE 2>/dev/null | wc -l | tr -d ' ' || echo "0")
            PHISHING=$(grep -c ",phishing" $BATCH_FILE 2>/dev/null || echo "0")
            LEGIT=$(grep -c ",legitimate" $BATCH_FILE 2>/dev/null || echo "0")

            echo "   Collected: $TOTAL URLs (Phishing: $PHISHING, Legitimate: $LEGIT)"

            if [ "$TOTAL" -lt 5 ]; then
              echo "âš ï¸ Too few URLs collected ($TOTAL), skipping this run"
              continue
            fi

            # ------------------------------------------------------------
            # STEP 3: Extract URL features locally
            # ------------------------------------------------------------
            echo ""
            echo "ğŸ” Step 3: Extracting URL features locally..."
            URL_FEATURES="data/processed/url_features_${BATCH_DATE}.csv"
            python3 scripts/extract_url_features.py $BATCH_FILE $URL_FEATURES

            # ------------------------------------------------------------
            # STEP 4: Upload to S3 and process on EC2
            # ------------------------------------------------------------
            echo ""
            echo "ğŸ“¤ Step 4: Uploading to S3..."
            aws s3 cp $BATCH_FILE s3://${{ env.S3_BUCKET }}/queue/batch_${BATCH_DATE}.csv
            aws s3 cp $URL_FEATURES s3://${{ env.S3_BUCKET }}/queue/url_features_${BATCH_DATE}.csv
            aws s3 cp scripts/extract_vm_features_aws.py s3://${{ env.S3_BUCKET }}/scripts/

            echo ""
            echo "ğŸ–¥ï¸ Step 5: Starting EC2 for DNS/WHOIS extraction..."

            # Check current state and handle accordingly
            INSTANCE_STATE=$(aws ec2 describe-instances --instance-ids ${{ env.EC2_INSTANCE_ID }} --query 'Reservations[0].Instances[0].State.Name' --output text)
            echo "   Current state: $INSTANCE_STATE"

            if [ "$INSTANCE_STATE" = "stopped" ]; then
              echo "   Starting instance..."
              aws ec2 start-instances --instance-ids ${{ env.EC2_INSTANCE_ID }}
              aws ec2 wait instance-running --instance-ids ${{ env.EC2_INSTANCE_ID }}
              sleep 60  # Wait for SSH to be ready
            elif [ "$INSTANCE_STATE" = "stopping" ]; then
              echo "   Waiting for instance to stop..."
              aws ec2 wait instance-stopped --instance-ids ${{ env.EC2_INSTANCE_ID }}
              echo "   Starting instance..."
              aws ec2 start-instances --instance-ids ${{ env.EC2_INSTANCE_ID }}
              aws ec2 wait instance-running --instance-ids ${{ env.EC2_INSTANCE_ID }}
              sleep 60  # Wait for SSH to be ready
            elif [ "$INSTANCE_STATE" = "pending" ]; then
              echo "   Waiting for instance to start..."
              aws ec2 wait instance-running --instance-ids ${{ env.EC2_INSTANCE_ID }}
              sleep 60  # Wait for SSH to be ready
            elif [ "$INSTANCE_STATE" = "running" ]; then
              echo "   Instance already running"
              sleep 10  # Brief wait for any ongoing operations
            else
              echo "   Unknown state: $INSTANCE_STATE, trying to start..."
              aws ec2 start-instances --instance-ids ${{ env.EC2_INSTANCE_ID }} || true
              aws ec2 wait instance-running --instance-ids ${{ env.EC2_INSTANCE_ID }}
              sleep 60
            fi

            # Get the public IP dynamically
            EC2_IP=$(aws ec2 describe-instances --instance-ids ${{ env.EC2_INSTANCE_ID }} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
            echo "   EC2 Public IP: $EC2_IP"

            echo ""
            echo "ğŸ” Step 6: Extracting DNS/WHOIS features on EC2..."
            ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/ec2_key ec2-user@$EC2_IP << EOFEC2
              cd /home/ec2-user/phishnet

              # Update the extraction script from S3
              aws s3 cp s3://${{ env.S3_BUCKET }}/scripts/extract_vm_features_aws.py scripts/

              # Run feature extraction with batch date (this downloads, extracts, merges, and uploads to S3)
              python3.8 scripts/extract_vm_features_aws.py ${BATCH_DATE}

              echo "âœ… EC2 processing complete!"
          EOFEC2

            echo ""
            echo "ğŸ›‘ Stopping EC2 instance..."
            aws ec2 stop-instances --instance-ids ${{ env.EC2_INSTANCE_ID }}

            # ------------------------------------------------------------
            # STEP 7: Download updated master and train models
            # ------------------------------------------------------------
            echo ""
            echo "ğŸ“¥ Step 7: Downloading updated master..."
            aws s3 cp s3://${{ env.S3_BUCKET }}/master/phishing_features_master.csv data/processed/phishing_features_complete.csv

            AFTER_COUNT=$(tail -n +2 data/processed/phishing_features_complete.csv | wc -l | tr -d ' ')
            NEW_ADDED=$((AFTER_COUNT - BEFORE_COUNT))
            echo "   Master now has $AFTER_COUNT URLs (+$NEW_ADDED new)"

            echo ""
            echo "ğŸ‹ï¸ Step 8: Preparing SEPARATE model-ready datasets (URL, DNS, WHOIS)..."
            python3 << 'EOFPY'
          import pandas as pd
          import numpy as np

          df = pd.read_csv('data/processed/phishing_features_complete.csv')
          print(f"Loaded {len(df)} rows, {len(df.columns)} columns")

          # Encode labels
          if 'label' in df.columns:
              df['label_encoded'] = (df['label'] == 'phishing').astype(int)
          elif 'label_encoded' not in df.columns:
              df['label_encoded'] = 0

          # Convert all object/string columns to numeric using factorize
          for col in df.columns:
              if df[col].dtype == 'object' and col not in ['url', 'label']:
                  df[col] = df[col].fillna('MISSING')
                  df[col], _ = pd.factorize(df[col])

          # Define SEPARATE feature groups from ORIGINAL extractors
          # URL features (39) - from url_features.py
          url_features = [
              'url_length', 'hostname_length', 'path_length', 'num_subdomains', 'num_dots',
              'num_special_chars', 'num_digits', 'num_uppercase_chars', 'has_at_symbol',
              'has_double_slash_redirect', 'has_dash_in_domain', 'is_ip_address', 'ip_category',
              'has_encoded_chars', 'has_non_ascii_chars', 'url_entropy', 'hostname_entropy',
              'digit_to_letter_ratio', 'domain_quality', 'tld_length', 'subdomain_entropy',
              'subdomain_length', 'has_login_keyword', 'has_suspicious_words', 'has_brand_mismatch',
              'file_type', 'is_file_download', 'is_script_file', 'is_shortened', 'num_fragments',
              'num_query_params', 'num_directories', 'port', 'is_risky_port', 'protocol_mismatch',
              'is_unknown_port', 'contains_hex_encoding', 'starts_with_https_but_contains_http',
              'missing_hostname_flag'
          ]

          # DNS features (31) - from dns_ipwhois.py
          dns_features = [
              'domain', 'has_A', 'num_A', 'has_AAAA', 'num_AAAA', 'has_MX', 'num_MX',
              'has_NS', 'num_NS', 'has_TXT', 'num_TXT', 'has_CNAME', 'cname_chain_length',
              'has_SOA', 'ttl_min', 'ttl_max', 'ttl_mean', 'ttl_var', 'mx_priority_min',
              'mx_priority_max', 'num_distinct_ips', 'txt_entropy', 'has_SPF', 'has_DKIM',
              'has_DMARC', 'has_wildcard_dns', 'dnssec_enabled', 'asn_list', 'asn_org_list',
              'asn_country_list', 'cidr_list', 'error_type'
          ]

          # WHOIS features (12) - from whois.py
          whois_features = [
              'registrar', 'whois_server', 'creation_date', 'expiration_date', 'updated_date',
              'domain_age_days', 'registration_length_days', 'status', 'registrant_country',
              'has_privacy_protection', 'whois_success', 'error_msg'
          ]

          # Filter to columns that exist
          url_cols = [c for c in url_features if c in df.columns]
          dns_cols = [c for c in dns_features if c in df.columns]
          whois_cols = [c for c in whois_features if c in df.columns]

          print(f"Features found: URL={len(url_cols)}, DNS={len(dns_cols)}, WHOIS={len(whois_cols)}")

          # Create SEPARATE model-ready files for each feature type
          # Save BOTH formats: _imputed (for training) and _modelready (for test_ensemble_combinations)
          for name, cols in [('url', url_cols), ('dns', dns_cols), ('whois', whois_cols)]:
              if not cols:
                  print(f"  WARNING: No {name.upper()} features found")
                  continue

              # Version for training (with label_encoded)
              df_train = df[cols + ['label_encoded']].copy().fillna(0)
              df_train.to_csv(f'data/processed/{name}_features_modelready_imputed.csv', index=False)

              # Version for test_ensemble_combinations.py (with url and label columns)
              if 'url' in df.columns:
                  df_test = df[['url'] + cols + ['label_encoded']].copy().fillna(0)
                  df_test = df_test.rename(columns={'label_encoded': 'label'})
                  df_test.to_csv(f'data/processed/{name}_features_modelready.csv', index=False)

              print(f"  Saved {name}_features_modelready.csv with {len(cols)} features")
          EOFPY

            echo ""
            echo "ğŸ‹ï¸ Step 9: Training 45 models with 5-fold CV (15 per feature type)..."
            mkdir -p models analysis
            python3 << 'EOFPY'
          import pandas as pd
          import numpy as np
          from sklearn.model_selection import StratifiedKFold
          from sklearn.metrics import roc_auc_score, accuracy_score, f1_score
          from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, AdaBoostClassifier, ExtraTreesClassifier, BaggingClassifier
          from sklearn.linear_model import LogisticRegression
          from sklearn.tree import DecisionTreeClassifier
          from sklearn.neighbors import KNeighborsClassifier
          from sklearn.naive_bayes import GaussianNB
          from sklearn.svm import SVC
          from sklearn.neural_network import MLPClassifier
          from catboost import CatBoostClassifier
          from lightgbm import LGBMClassifier
          from xgboost import XGBClassifier
          import joblib
          import json
          import warnings
          warnings.filterwarnings('ignore')

          models = {
              'random_forest': RandomForestClassifier(n_estimators=100, random_state=42, n_jobs=-1),
              'gradient_boost': GradientBoostingClassifier(n_estimators=100, random_state=42),
              'adaboost': AdaBoostClassifier(n_estimators=100, random_state=42, algorithm='SAMME'),
              'logistic': LogisticRegression(max_iter=1000, random_state=42),
              'decision_tree': DecisionTreeClassifier(random_state=42),
              'knn': KNeighborsClassifier(n_neighbors=5),
              'naive_bayes': GaussianNB(),
              'svm': SVC(probability=True, random_state=42),
              'mlp': MLPClassifier(hidden_layer_sizes=(100,), max_iter=500, random_state=42),
              'catboost': CatBoostClassifier(iterations=100, random_state=42, verbose=0),
              'lightgbm': LGBMClassifier(n_estimators=100, random_state=42, verbose=-1),
              'xgboost': XGBClassifier(n_estimators=100, random_state=42, verbosity=0),
              'extra_trees': ExtraTreesClassifier(n_estimators=100, random_state=42, n_jobs=-1),
              'bagging': BaggingClassifier(n_estimators=50, random_state=42),
              'voting_base': RandomForestClassifier(n_estimators=50, random_state=42),
          }

          skf = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

          # Train SEPARATE models for each feature type with 5-fold CV
          for feature_type in ['url', 'dns', 'whois']:
              print(f"\n{'='*60}")
              print(f"Training {feature_type.upper()} models with 5-fold CV...")
              print(f"{'='*60}")

              try:
                  df = pd.read_csv(f'data/processed/{feature_type}_features_modelready_imputed.csv')
              except FileNotFoundError:
                  print(f"  Skipping {feature_type} - no data file")
                  continue

              X = df.drop('label_encoded', axis=1)
              y = df['label_encoded'].values
              feature_cols = list(X.columns)

              print(f"  {len(X)} samples, {len(feature_cols)} features")

              if len(np.unique(y)) < 2:
                  print(f"  Skipping {feature_type} - only one class")
                  continue

              cv_results = []

              for name, model_template in models.items():
                  # Clone model for each iteration
                  import copy
                  fold_rocs = []
                  fold_accs = []
                  fold_f1s = []

                  try:
                      for fold, (tr_idx, va_idx) in enumerate(skf.split(X, y), 1):
                          model = copy.deepcopy(model_template)
                          X_tr, X_va = X.iloc[tr_idx], X.iloc[va_idx]
                          y_tr, y_va = y[tr_idx], y[va_idx]

                          model.fit(X_tr, y_tr)

                          if hasattr(model, 'predict_proba'):
                              probs = model.predict_proba(X_va)[:, 1]
                          else:
                              scores = model.decision_function(X_va)
                              probs = (scores - scores.min()) / (scores.max() - scores.min() + 1e-12)

                          preds = (probs >= 0.5).astype(int)

                          fold_rocs.append(roc_auc_score(y_va, probs))
                          fold_accs.append(accuracy_score(y_va, preds))
                          fold_f1s.append(f1_score(y_va, preds))

                      # Average metrics across folds
                      mean_roc = np.mean(fold_rocs)
                      mean_acc = np.mean(fold_accs)
                      mean_f1 = np.mean(fold_f1s)

                      cv_results.append({
                          'model': name,
                          'roc_auc': mean_roc,
                          'accuracy': mean_acc,
                          'f1': mean_f1
                      })

                      # Final fit on all data and save
                      final_model = copy.deepcopy(model_template)
                      final_model.fit(X, y)
                      joblib.dump(final_model, f'models/{feature_type}_{name}.pkl')
                      joblib.dump(feature_cols, f'models/{feature_type}_{name}_feature_cols.pkl')

                      print(f"    {name}: ROC={mean_roc:.4f} ACC={mean_acc:.4f} F1={mean_f1:.4f}")

                  except Exception as e:
                      print(f"    {name}: FAILED - {e}")

              # Save CV results for this feature type (needed by test_ensemble_combinations.py)
              if cv_results:
                  cv_df = pd.DataFrame(cv_results).sort_values('roc_auc', ascending=False)
                  cv_df.to_csv(f'analysis/{feature_type}_cv_results.csv', index=False)
                  print(f"\n  ğŸ“Š Saved analysis/{feature_type}_cv_results.csv")
                  print(f"     Top 3: {list(cv_df.head(3)['model'].values)}")
          EOFPY

            echo ""
            echo "ğŸ”— Step 10: Testing ensemble combinations (top 3 Ã— top 3 Ã— top 3 Ã— 4 weights = 108)..."
            python3 scripts/test_ensemble_combinations.py || {
              echo "âš ï¸ Ensemble combination testing failed, trying fallback..."
              # Fallback: use simplified ensemble comparison
              python3 scripts/ensemble_comparison.py --test-size 500 --iterations 20 || echo "Fallback also failed"
            }

            # Get best results from training
            BEST_ACC="N/A"
            BEST_F1="N/A"
            BEST_NAME="N/A"
            if [ -f "models/training_results.json" ]; then
              echo ""
              echo "ğŸ“Š Training Results:"
              cat models/training_results.json
              echo ""
              BEST_ACC=$(python3 -c "
          import json
          r = json.load(open('models/training_results.json'))
          all_accs = []
          for feature_type, models in r.items():
              if models:
                  for name, acc in models.items():
                      all_accs.append(acc)
          if all_accs:
              print(f'{max(all_accs):.4f}')
          else:
              print('N/A')
          " 2>/dev/null || echo "N/A")
              echo "Best model accuracy: $BEST_ACC"
            fi

            LATEST_ENSEMBLE=$(ls -t analysis/ensemble_comparison/comparison_*.json 2>/dev/null | head -1)
            if [ -n "$LATEST_ENSEMBLE" ]; then
              echo ""
              echo "ğŸ“Š Ensemble Results from: $LATEST_ENSEMBLE"
              BEST_F1=$(python3 -c "import json; r=json.load(open('$LATEST_ENSEMBLE')); print(f\"{r[0].get('f1_score', 'N/A'):.4f}\" if isinstance(r, list) and r else 'N/A')" 2>/dev/null || echo "N/A")
              BEST_NAME=$(python3 -c "import json; r=json.load(open('$LATEST_ENSEMBLE')); print(r[0].get('name', 'N/A') if isinstance(r, list) and r else 'N/A')" 2>/dev/null || echo "N/A")
              BEST_ENS_ACC=$(python3 -c "import json; r=json.load(open('$LATEST_ENSEMBLE')); print(f\"{r[0].get('accuracy', 'N/A'):.4f}\" if isinstance(r, list) and r else 'N/A')" 2>/dev/null || echo "N/A")
              echo "Best ensemble: $BEST_NAME (Accuracy: $BEST_ENS_ACC, F1: $BEST_F1)"
            else
              echo "âš ï¸ No ensemble comparison results found"
            fi

            # Record results
            echo "$RUN_NUM,$AFTER_COUNT,$NEW_ADDED,$PHISHING,$LEGIT,$BEST_ACC,$BEST_F1,$BEST_NAME" >> $RESULTS_FILE

            echo ""
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘               RUN $RUN_NUM COMPLETE                              â•‘"
            echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
            echo "â•‘  Dataset: $BEFORE_COUNT â†’ $AFTER_COUNT URLs (+$NEW_ADDED new)              "
            echo "â•‘  Best Accuracy: $BEST_ACC                                    "
            echo "â•‘  Best Ensemble: $BEST_NAME                                   "
            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

            # Small delay between runs
            sleep 5
          done

          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘            ALL VALIDATION RUNS COMPLETE                      â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "Results saved to: $RESULTS_FILE"
          cat $RESULTS_FILE

      - name: Upload validation results
        uses: actions/upload-artifact@v4
        with:
          name: validation-results-${{ github.run_id }}
          path: |
            analysis/validation_runs/
            analysis/ensemble_comparison/
            models/training_results.json
          retention-days: 30
